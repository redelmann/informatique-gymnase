---
title: Des tables aux propositions
order: 7
---

<p>
    Comme nous le verrons dans le chapitre suivant,
    nous serons parfois amenés à chercher une proposition étant donné sa table de vérité.
    En effet, parfois la liste des interprétations que l'on souhaite satisfaire nous sera donnée,
    et nous serons intéressés à trouver une proposition qui leur correspond.
    Nous allons donc étudier ici une méthode pour concevoir une proposition à partir de sa table de vérité.
</p>

<p>
    Pour illustrer la méthode que nous allons utiliser, considérons ensemble un exemple.
    Soit la table de vérité suivante qui correspond à une proposition que l'on souhaite déterminer :
</p>

<table class="truth-table">
    <tr>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th class="delimited">?</th>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
</table>

<p>
    Pour déterminer la proposition correspondante, nous allons procéder de la façon suivante :    
    Commençons par chercher une collection de variables (ou de négations de variables) dont la conjonction satisfait le plus grand nombre d'interprétations que l'on désire, sans toutefois satisfaire des interprétations indésirables.
    Visuellement, on va chercher à trouver une combinaison de variables ou de leur négation qui couvre le plus grand nombre possible de lignes de la table de vérité où la valeur de vérité de la proposition est 1,
    sans toutefois couvrir de lignes où la valeur est 0.
</p>
<p>
    À noter que la conjonction que l'on utilisera ne doit pas forcément faire usage de toutes les variables.
    En effet, si on utilise toutes les variables, alors une seule interprétation sera couverte.
    Plus le nombre de variables utilisées est petit, plus le nombre d'interprétations couvertes est grand.
    Au mieux, on utilisera une seule variable (ou sa négation), quand cela sera possible.
</p>
<p>
    Ici, pour notre exemple, une seule variable ne suffira malheureusement pas.
    Nous allons donc essayer d'utiliser deux variables.
    Ici, la conjonction <code>(non A) et B</code> permet de couvrir deux lignes de la table de vérité :
</p>

<table class="truth-table">
    <tr>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th class="delimited">?</th>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
    <tr class="highlighted">
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">1</td>
    </tr>
    <tr class="highlighted">
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
</table>

<p>
    Prenons note de cette conjonction.
</p>

<p>
    Une fois cette première conjonction trouvée, on cherche à couvrir le reste des lignes à l'aide d'autres conjonctions, selon le même procédé.
    À chaque fois, on cherche à trouver une conjonction qui couvre le plus grand nombre de lignes <i>non-couvertes</i> de la table de vérité où la valeur de vérité de la proposition est 1,
    sans toutefois couvrir des lignes où la valeur de vérité de la proposition est 0.
</p>

<p>
    Dans notre cas, il suffit d'ajouter la conjonction <code>A et (non B) et C</code> pour couvrir la ligne manquante dans la table de vérité.
</p>

<table class="truth-table">
    <tr>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th class="delimited">?</th>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
    <tr class="dimmed">
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">1</td>
    </tr>
    <tr class="dimmed">
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr class="highlighted">
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td class="delimited">1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td class="delimited">0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td class="delimited">0</td>
    </tr>
</table>

<p>
    À noter qu'il est possible de couvrir certaines lignes à plusieurs reprises.
    Cela permet parfois de trouver une proposition plus courte.
</p>

<p>
    Une fois toutes les lignes couvertes, il suffit de prendre comme résultat la disjonction de toutes les conjonctions trouvées.
    Dans le cas présent, la proposition obtenue est <code>((non A) et B) ou (A et (non B) et C)</code>.
</p>

$remark$
<p>
    Pour des cas plus complexes, la méthode des <a href="https://fr.wikipedia.org/wiki/Table_de_Karnaugh">tables de Karnaugh</a> peut être utilisée.
    La méthode se base sur le même procédé que décrit ici mais utilise une représentation graphique des valeurs de vérité sous forme de table qui permet d'identifier plus facilement les conjonctions de variables à utiliser.
    Les tables de Karnaugh diffèrent légérement des tables de vérité dans leur présentation, permettant ainsi de plus facilement établir
    des conjonctions de variables qui couvrent le plus grand nombre possible d'interprétations.
</p>
$endremark$

$selfcheck$
<p>
    Soit la table de vérité suivante :
</p>
<table id="self-check-table-1" class="truth-table"></table>
<p>
    Une proposition qui correspond à cette table de vérité est 
    <select class="self-pick code">
        <option>faux</option>
        <option>A</option>
        <option>B</option>
        <option>non A</option>
        <option>non B</option>
        <option>A et B</option>
        <option>A ou B</option>
        <option data-correct>A et (non B)</option>
        <option>A ou (non B)</option>
        <option>(non A) et B</option>
        <option>(non A) ou B</option>
        <option>(non A) et (non B)</option>
        <option>(non A) ou (non B)</option>
        <option>vrai</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Soit la table de vérité suivante :
</p>
<table id="self-check-table-2" class="truth-table"></table>
<p>
    Une proposition qui correspond à cette table de vérité est 
    <select class="self-pick code">
        <option>faux</option>
        <option>A</option>
        <option>B</option>
        <option>non A</option>
        <option>non B</option>
        <option>A et B</option>
        <option>A ou B</option>
        <option>A et (non B)</option>
        <option>A ou (non B)</option>
        <option>(non A) et B</option>
        <option data-correct>(non A) ou B</option>
        <option>(non A) et (non B)</option>
        <option>(non A) ou (non B)</option>
        <option>vrai</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Soit la table de vérité suivante :
</p>
<table id="self-check-table-3" class="truth-table"></table>
<p>Entrez une proposition qui correspond à cette table de vérité.</p>
<div class="expr-input" id="self-check-ex-3-in">
    <input type="text" placeholder="" autocomplete="off" autocorrect="off" autocapitalize="off" />
    <button>Vérifier</button>
</div>
<div id="self-check-ex-3-out" style="margin-bottom: 10px;"></div>
$endselfcheck$

$selfcheck$
<p>
    Soit la table de vérité suivante :
</p>
<table id="self-check-table-4" class="truth-table"></table>
<p>Entrez une proposition qui correspond à cette table de vérité.</p>
<div class="expr-input" id="self-check-ex-4-in">
    <input type="text" placeholder="" autocomplete="off" autocorrect="off" autocapitalize="off" />
    <button>Vérifier</button>
</div>
<div id="self-check-ex-4-out" style="margin-bottom: 10px;"></div>
$endselfcheck$

<script src="/js/truth-tables.js"></script>

<script type="text/javascript">
(function() {
    populateTable('self-check-table-1', 'A et (non B)', ['?']);
    populateTable('self-check-table-2', 'non A ou B', ['?']);
    populateTable('self-check-table-3', 'non A et B ou A et non B', ['?']);
    populateTable('self-check-table-4', 'C ou (non A et B)', ['?']);

    function handler(input, output, targetExpr) {
        output.innerHTML = '';
        const text = input.value;
        let expr;
        try {
            expr = logicQuestions.parse(text);
        } catch (e) {
            output.innerHTML = '<p>Oups, la proposition est mal formée.</p>';
            return;
        }
        const model = logicQuestions.getCounterExample(logicQuestions.iff(expr, targetExpr));
        if (model === null) {
            output.innerHTML = '<p>Correct ! Bravo !</p>';

        } else {
            output.innerHTML = '<p>Ce n\'est pas tout à fait ça.</p>';
            const table = document.createElement('table');
            table.classList.add('truth-table');
            output.appendChild(table);
            populateTable(table, [targetExpr, expr], ['La cible', 'Votre proposition']);
        }
    }

    function setupCheckEquiv(id, targetExpr) {
        const input = document.getElementById(id + '-in').querySelector('input');
        const output = document.getElementById(id + '-out');
        const button = document.getElementById(id + '-in').querySelector('button');
        button.addEventListener('click', function() {
            handler(input, output, targetExpr);
        });
        input.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                handler(input, output, targetExpr);
            }
        });
    }

    setupCheckEquiv('self-check-ex-3', logicQuestions.parse('non A et B ou A et non B'));
    setupCheckEquiv('self-check-ex-4', logicQuestions.parse('C ou (non A et B)'));
})();
</script>

