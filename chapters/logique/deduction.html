---
title: La déduction naturelle
order: 8
---

<link rel="stylesheet" href="/css/fitch-light.css" />
<script src="/js/fitch.js"></script>

<style>
    .informal-proof {
        font-style: italic;
        padding-left: 20px;
        border-left: #ccc 2px solid;
        color : #666;
    }
</style>

<div class="illustration right">
    <img src="images/tampon.png" style="margin-top: 30px; margin-bottom: 30px;" alt="Un tampon encreur de validation." />
</div>

<p>
    Jusqu'à présent, nous avons vu un unique moyen de démontrer la validité d'une proposition :
    vérifier que la formule vaut 1 pour toutes les interprétations possibles.
    Autrement dit, pour montrer qu'une proposition est toujours vraie,
    il nous fallait établir une table de vérité et vérifier que la colonne correspondant à la proposition ne contient bien que des 1.
    Cette méthode est parfois très longue, voire tout simplement inapplicable dans des logiques plus complexes
    tels que la <i>logique des prédicats</i> souvent employée en mathématiques,
    où il est impossible de tester toutes les interprétations possibles.
</p>

<p>
    Dans cette section, nous allons étudier un système de déduction inventé par le logicien allemand <a href="https://fr.wikipedia.org/wiki/Gerhard_Gentzen">Gerhard Gentzen</a> au début du vingtième siècle et appelé la <i>déduction naturelle</i>.
    Ce système est basé sur l'idée que la validité d'une proposition peut être démontrée en appliquant des <i>règles d'inférence</i>.
    Ces règles d'inférence sont des règles de raisonnement qui permettent de déduire la validité d'une proposition à partir de celle d'autres propositions.
    Ce système de déduction naturelle est une manière formelle de démontrer la validité d'une proposition sans avoir à énumérer toutes ses interprétations.
    Nous allons voir dans cette section comment construire des preuves de propositions à l'aide de ce système.
</p>

$remark$
<p>
    Cette section est optionnelle.
    Le matériel présenté ici n'est pas nécessaire pour comprendre les autres sections du cours.
    Cependant, les lecteurs intéressés pourront trouver dans cette section
    des clés intéressantes pour comprendre ce qu'est une <i>preuve</i> mathématique,
    ainsi que des outils de raisonnement formel.
</p>
<p>
    Il y a aussi des liens très forts entre la déduction naturelle et la programmation.
    Pour les plus intéressés (et téméraires), je vous conseille la lecture de
    <a href="https://fr.wikipedia.org/wiki/Correspondance_de_Curry-Howard">la page Wikipédia sur la <i>correspondance de Curry-Howard</i></a>.
</p>
$endremark$

<h3>Preuve</h3>

<p>
    Une preuve est un raisonnement qui permet d'établir qu'une proposition est valide.
    Une preuve est généralement constituée d'une suite d'étapes.
    À chaque étape, on montre qu'une proposition est valide à partir de la validité d'autres propositions
    déjà démontrées.
</p>

<p>
    Parfois, une preuve utilisera des hypothèses, c'est-à-dire des propositions qu'on suppose vraies sans avoir à les démontrer.
    Les preuves peuvent aussi faire appel à des sous-preuves, c'est-à-dire des preuves dans la preuve,
    qui permettent de démontrer une proposition à partir d'une hypothèse provisoire.
</p>

<p>
    Commençons par un exemple de preuve, retranscrite tout d'abord en français.
    La preuve cherche à démontrer que si on admet <code>A ou B</code> et <code>non A</code>,
    alors on peut en déduire <code>B</code>.
    La preuve est ci-dessous :
</p>

<div class="informal-proof">
    <p>
        Posons comme première hypothèse <code>A ou B</code> et comme deuxième hypothèse <code>non A</code>.
        De la première hypothèse, on sait que <code>A</code> ou <code>B</code> est vrai.
        Analysons les deux cas possibles.
    </p>
    <ul>
        <li>
            Admettons d'abord que <code>A</code> est vrai.
            Or, dans ce cas, on peut conclure à une contradiction, car <code>A</code> est vrai
            par hypothèse provisoire et <code>non A</code> est vrai par hypothèse.
            Ce cas est donc impossible, on peut donc conclure ce que l'on veut,
            par exemple que <code>B</code> est vrai.
        </li>
        <li>
            Admettons maintenant que <code>B</code> est vrai.
            Alors, on peut conclure immédiatement que <code>B</code> est vrai
            par notre hypothèse provisoire.
        </li>
    </ul>
    <p>
        Dans les deux cas, on peut conclure que <code>B</code> est vrai,
        ce qui conclut la preuve que <code>B</code> est vrai.
    </p>
</div>

<p>
    Ci-dessous est présenté la même preuve dans une notation appelée <i>style de Fitch</i>.
    Il s'agit d'une preuve formelle de la validité de la proposition <code>B</code>
    étant données les deux hypothèses <code>A ou B</code> et <code>non A</code>.
    Dans cette présentation figurent
    toutes les étapes qui permettent d'arriver à la conclusion.
    Contrairement à la preuve en français ci-dessus,
    chaque étape est justifiée de manière explicite par l'utilisation
    d'une règle d'inférence nommée.
    Chaque étape est très simple et ainsi peut être facilement vérifiée
    par un lecteur ou même un ordinateur.
</p>

<div id="ex-proof"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "A ou B",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "non A",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "A",
            "rule": "assumption",
            "refs": []
            },
            "parts": [
            {
                "type": "line",
                "expr": "faux",
                "rule": "notE",
                "refs": [
                "2",
                "3"
                ]
            }
            ],
            "conclusion": {
            "type": "line",
            "expr": "B",
            "rule": "falseE",
            "refs": [
                "4"
            ]
            }
        },
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "B",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "B",
            "rule": "rep",
            "refs": [
                "6"
            ]
            }
        },
        {
            "type": "line",
            "expr": "B",
            "rule": "orE",
            "refs": [
            "1",
            "3-5",
            "6-7"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-proof"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    L'exemple ci-dessus montre comment on peut démontrer la validité de la proposition
    <code>B</code> (ligne 8) étant données les deux hypothèses <code>A ou B</code> et <code>non A</code>
    (lignes 1 et 2).
    La preuve est constituée de plusieurs étapes.
    À chaque étape, on utilise une règle d'inférence pour montrer qu'une proposition est valide
    à partir de la validité d'autres propositions déjà démontrées.
</p>

<p>
    Les lignes 3-5, ainsi que les lignes 6-7, sont ce qu'on appelle des <i>sous-preuves</i>.
    Les sous-preuves permettent d'assumer temporairement une hypothèse
    (appelée <i>hypothèse provisoire</i>) afin d'arriver à une certaine conclusion.
    Pour la sous-preuve des lignes 3-5, l'hypothèse provisoire est <code>A</code> (ligne 3)
    et la conclusion est <code>B</code> (ligne 5).
    Pour la sous-preuve des lignes 6-7, l'hypothèse provisoire est <code>B</code> (ligne 6)
    et la conclusion est <code>B</code> (ligne 7).
    Ces sous-preuves peuvent être référencées dans la suite de la preuve,
    mais les propositions qu'elles contiennent ne sont pas considérées comme
    démontrées en dehors de ces sous-preuves.
    En effet, elles ne sont valides que si l'hypothèse provisoire est vraie.
</p>

<p>
    Pour clarifier la présentation sur cette page,
    on utilise un code couleur pour distinguer les hypothèses des étapes
    qui découlent d'un raisonnement logique.
    Les hypothèses sont des propositions qu'on suppose vraies sans avoir à les démontrer.
</p>

$remark$
<p>
    Les preuves notées sur cette pages sont notées dans un style appelé <i>style Fitch</i>.
    Ce style a été inventé par le logicien américain <a href="https://fr.wikipedia.org/wiki/Frederic_Brenton_Fitch">Frederic Brenton Fitch</a>.
</p>
$endremark$

$tryout$
<p>
    Vous pouvez reproduire les preuves vues sur cette page,
    et en créer de nouvelles, en utilisant l'<a href="/fitch.html">assistant de preuve
    disponible sur ce site</a>.
</p>
$endtryout$

<h3>Règle d'inférence</h3>

<p>
    Une règle d'inférence est une règle de raisonnement qui
    permet d'établir qu'une proposition est valide à partir de
    la validité d'autres propositions.
    Les différentes règles d'inférence sont présentées ci-dessous,
    chacune accompagnée d'un exemple.
</p>

<h4>Hypothèse</h4>

<p>
    La règle d'inférence <i>Hypothèse</i> permet d'ajouter une hypothèse à une preuve.
    Une hypothèse est une proposition qu'on suppose vraie sans avoir à la démontrer.
    On peut ensuite utiliser cette hypothèse pour démontrer d'autres propositions.
</p>

<div id="ex-hypothese"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P ou Q",
            "rule": "hypothesis",
            "refs": []
        },
    ]);

    setUpFitch(proof, document.getElementById("ex-hypothese"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Les hypothèses sont mises en jaune pour les distinguer des autres propositions.
    Il est en effet important de pouvoir les distinguer des autres propositions
    car elles ne sont pas démontrées mais simplement admises.
</p>

<h4>Répétition</h4>

<p>
    La règle d'inférence <i>Répétition</i> permet de répéter une proposition déjà démontrée.
    Cette règle est utile pour réutiliser une proposition déjà démontrée
    plus tôt dans la preuve.
</p>

<div id="ex-rep"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P",
            "rule": "rep",
            "refs": ['1']
        },
    ]);

    setUpFitch(proof, document.getElementById("ex-rep"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 2 est prouvée en utilisant la règle d'inférence <i>Répétition</i>.
    La ligne 2 est une répétition de la ligne 1.
    Le numéro de la ligne reproduite est indiqué après le nom de la règle d'inférence.
</p>

<h4>Introduction de <code>vrai</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>vrai</code></i>
    permet de démontrer la proposition <code>vrai</code>
    sans avoir à utiliser d'autres propositions.
</p>

<div id="ex-trueI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "vrai",
            "rule": "trueI",
            "refs": []
        },
    ]);

    setUpFitch(proof, document.getElementById("ex-trueI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 1 est directement
    validée par la règle d'inférence <i>Introduction de <code>vrai</code></i>.
</p>

<p>
    On appelle cette règle une règle d'introduction car elle permet d'introduire
    la proposition <code>vrai</code> dans une preuve.
</p>

<h4>Élimination de <code>faux</code></h4>

<p>
    La règle d'inférence <i>Élimination de <code>faux</code></i>
    permet de démontrer n'importe quelle proposition
    à partir de la proposition <code>faux</code>.
</p>

<div id="ex-falseE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "faux",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P",
            "rule": "falseE",
            "refs": ['1']
        },
    ]);

    setUpFitch(proof, document.getElementById("ex-falseE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 2 est démontrée
    à partir de la ligne 1 en utilisant la règle d'inférence <i>Élimination de <code>faux</code></i>.
</p>

<p>
    La règle d'inférence <i>Élimination de <code>faux</code></i> est une règle très puissante.
    Elle permet de démontrer n'importe quelle proposition à partir d'une contradiction.
    On appelle aussi cette règle le <i>principe d'explosion</i>.
</p>

<h4>Introduction de <code>non</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>non</code></i>
    permet de démontrer une proposition de la forme <code>non p</code>,
    pour n'importe quelle proposition <code>p</code>,
    à partir d'une sous-preuve qui aboutit à une contradiction
    en admettant de l'hypothèse provisoire <code>p</code>.
</p>

<p>
    Plus simplement, la règle stipule que si l'on peut démontrer une contradiction
    en supposant <code>p</code>, alors on peut démontrer <code>non p</code>.
</p>

<div id="ex-notI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "P",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "faux",
            "rule": "hypothesis",
            "refs": []
            }
        },
        {
            "type": "line",
            "expr": "non P",
            "rule": "notI",
            "refs": [
            "1-2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-notI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    à partir de la sous-preuve des lignes 1 à 2.
    Cette sous-preuve prend l'hypothèse <code>P</code> et
    aboutit à une contradiction.
</p>

<h4>Élimination de <code>non</code></h4>

<p>
    La règle d'inférence <i>Élimination de <code>non</code></i>
    permet de démontrer une contradiction (c'est-à-dire la proposition <code>faux</code>)
    à partir d'une proposition de la forme <code>non p</code> et de la proposition <code>p</code>.
</p>

<div id="ex-notE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "non P",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "faux",
            "rule": "notE",
            "refs": [
            "1",
            "2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-notE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3, qui contient la proposition <code>faux</code>,
    est démontrée à partir des lignes 1 et 2 qui contiennent une proposition et sa négation.
</p>

<h4>Introduction de <code>et</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>et</code></i>
    permet de démontrer une proposition de la forme <code>p et q</code>,
    à partir des propositions <code>p</code> et <code>q</code> déjà démontrées.
</p>

<p>
    Plus simplement, la règle stipule que si l'on peut démontrer deux propositions
    <code>p</code> et <code>q</code>, alors on peut démontrer <code>p et q</code>.
</p>

<div id="ex-andI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "Q",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P et Q",
            "rule": "andI",
            "refs": [
            "1",
            "2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-andI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    à partir des lignes 1 et 2 en utilisant la règle d'inférence <i>Introduction de <code>et</code></i>.
</p>

<h4>Élimination de <code>et</code></h4>

<p>
    Quand une preuve contient une proposition de la forme <code>p et q</code>,
    il est possible de démontrer <code>p</code>, respectivement <code>q</code>,
    en utilisant une règle d'inférence appelée <i>Élimination de <code>et</code></i>.
    Cette règle existe en deux variantes : <i>Élimination gauche de <code>et</code></i>
    et <i>Élimination droite de <code>et</code></i>, selon que l'on souhaite garder la partie
    gauche ou droite de la conjonction.
</p>

<div id="ex-andE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P et Q",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P",
            "rule": "andE1",
            "refs": [
            "1"
            ]
        },
        {
            "type": "line",
            "expr": "Q",
            "rule": "andE2",
            "refs": [
            "1"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-andE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 2 est démontrée
    à partir de la ligne 1 en utilisant la règle d'inférence <i>Élimination gauche de <code>et</code></i>.
    De même, la ligne 3 est démontrée à partir de la ligne 1
    en utilisant la règle d'inférence <i>Élimination droite de <code>et</code></i>.
</p>

<h4>Introduction de <code>ou</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>ou</code></i>
    permet de démontrer une proposition de la forme <code>p ou q</code>,
    à partir d'une proposition <code>p</code> ou d'une proposition <code>q</code> déjà démontrée.
</p>

<p>
    De manière intuitive, la règle stipule que l'on peut démontrer un disjonction
    <code>p ou q</code> en démontrant <code>p</code> ou en démontrant <code>q</code>.
</p>

<p>
    Cette règle existe elle aussi en deux variantes : <i>Introduction gauche de <code>ou</code></i>
    et <i>Introduction droite de <code>ou</code></i>, selon que l'on souhaite introduire
    la disjonction à partir de la partie gauche ou droite.
</p>

<div id="ex-orI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "P ou Q",
            "rule": "orI1",
            "refs": [
            "1"
            ]
        },
        {
            "type": "line",
            "expr": "Q ou P",
            "rule": "orI2",
            "refs": [
            "1"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-orI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans la preuve ci-dessus, la ligne 2 est démontrée
    à partir de la ligne 1 en utilisant la règle d'inférence <i>Introduction gauche de <code>ou</code></i>.
    De même, la ligne 3 est démontrée à partir de la ligne 1
    en utilisant la règle d'inférence <i>Introduction droite de <code>ou</code></i>.
</p>

<h4>Élimination de <code>ou</code></h4>

<p>
    La règle d'inférence <i>Élimination de <code>ou</code></i>
    permet de faire ce qu'on appelle un <i>raisonnement par cas</i>.
    Étant donnée une proposition de la forme <code>p ou q</code>,
    on peut démontrer une autre proposition <code>r</code> en démontrant
    que l'on peut démontrer <code>r</code> à partir de <code>p</code> et
    que l'on peut aussi démontrer <code>r</code> à partir de <code>q</code>.
</p>

<p>
    Autrement, si on sait qu'une de deux propositions <code>p</code> ou <code>q</code> est vraie,
    et que dans les deux cas on peut démontrer <code>r</code>,
    alors on peut démontrer <code>r</code>.
</p>

<div id="ex-orE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "A ou B",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "A",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "B ou A",
            "rule": "orI2",
            "refs": [
                "2"
            ]
            }
        },
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "B",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "B ou A",
            "rule": "orI1",
            "refs": [
                "4"
            ]
            }
        },
        {
            "type": "line",
            "expr": "B ou A",
            "rule": "orE",
            "refs": [
            "1",
            "2-3",
            "4-5"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-orE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 6 est démontrée à l'aide de la règle d'inférence <i>Élimination de <code>ou</code></i>
    à partir de la ligne 1 et des sous-preuves des lignes 2-3 et 4-5.
    La ligne 1 établit que <code>A ou B</code> est vraie.
    La sous-preuve des lignes 2-3 établit que <code>B ou A</code> est vraie
    si <code>A</code> est vraie.
    De même, la sous-preuve des lignes 4-5 établit que <code>B ou A</code> est vraie
    si <code>B</code> est vraie.
    Ainsi, on peut déduire que <code>B ou A</code> est vraie dans tous les cas.
</p>

<h4>Introduction de <code>implique</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>implique</code></i>
    permet de démontrer une proposition de la forme <code>p implique q</code>,
    à partir d'une sous-preuve qui aboutit à la proposition <code>q</code>
    en admettant de l'hypothèse provisoire <code>p</code>.
</p>

<div id="ex-implI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "A",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "B",
            "rule": "hypothesis",
            "refs": []
            }
        },
        {
            "type": "line",
            "expr": "A implique B",
            "rule": "implI",
            "refs": [
            "1-2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-implI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    en utilisant la règle d'inférence <i>Introduction de <code>implique</code></i>
    à partir de la sous-preuve des lignes 1 à 2.
    Dans cette sous-preuve, on a établit qu'il était possible de démontrer <code>B</code>
    en admettant de l'hypothèse provisoire <code>A</code>.
    Ainsi, on peut déduire que <code>A implique B</code> est vraie.
</p>

<h4>Élimination de <code>implique</code></h4>

<p>
    La règle d'inférence <i>Élimination de <code>implique</code></i>
    permet de démontrer une proposition de la forme <code>q</code>,
    à partir d'une proposition de la forme <code>p implique q</code>
    et d'une proposition de la forme <code>p</code>.
</p>

<p>
    Autrement dit, si on sait que <code>p implique q</code> est vraie,
    et que <code>p</code> est vraie, alors on peut déduire que <code>q</code> est vraie.
</p>

<p>
    Cette règle de raisonnement est aussi connue sous son nom latin : <a href="https://fr.wikipedia.org/wiki/Modus_ponens"><i>modus ponens</i></a>.
</p>

<div id="ex-implE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "A implique B",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "A",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "B",
            "rule": "implE",
            "refs": [
            "1",
            "2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-implE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    en utilisant la règle d'inférence <i>Élimination de <code>implique</code></i>
    à partir des lignes 1 et 2.
    La ligne 1 stipule que <code>A implique B</code> est vraie,
    et la ligne 2 stipule que <code>A</code> est vraie.
    Ensemble, ces deux lignes permettent de déduire que <code>B</code> est vraie.
</p>

<h4>Introduction de <code>ssi</code></h4>

<p>
    La règle d'inférence <i>Introduction de <code>ssi</code></i>
    permet de démontrer une proposition de la forme <code>p ssi q</code>,
    à partir de deux implications : <code>p implique q</code> et <code>q implique p</code>.
</p>

<p>
    En effet, deux propositions <code>p</code> et <code>q</code> sont équivalentes
    si <code>p implique q</code> et <code>q implique p</code> sont toutes les deux vraies.
</p>

<div id="ex-iffI"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "A implique B",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "B implique A",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "A ssi B",
            "rule": "iffI",
            "refs": [
            "1",
            "2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-iffI"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    en utilisant la règle d'inférence <i>Introduction de <code>ssi</code></i>
    à partir des lignes 1 et 2.
</p>

<h4>Élimination de <code>ssi</code></h4>

<p>
    La règle d'inférence <i>Élimination de <code>ssi</code></i>
    permet d'obtenir deux implications à partir d'une proposition de la forme <code>p ssi q</code>.
    La règle a deux variantes : <i>Élimination gauche de <code>ssi</code></i>,
    qui permet d'obtenir <code>p implique q</code>, et <i>Élimination droite de <code>ssi</code></i>,
    qui permet d'obtenir <code>q implique p</code>.
</p>

<div id="ex-iffE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "A ssi B",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "A implique B",
            "rule": "iffE1",
            "refs": [
            "1"
            ]
        },
        {
            "type": "line",
            "expr": "B implique A",
            "rule": "iffE2",
            "refs": [
            "1"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-iffE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 2 est démontrée
    par la règle d'inférence <i>Élimination gauche de <code>ssi</code></i>,
    alors que la ligne 3 est démontrée
    par la règle d'inférence <i>Élimination droite de <code>ssi</code></i>.
</p>

<h4>Principe du tiers exclu</h4>

<p>
    Le principe du tiers exclu stipule que pour toute proposition <code>p</code>,
    la proposition <code>p ou non p</code> est vraie.
    Autrement dit, une proposition est soit vraie, soit fausse.
    Il n'y a pas de troisième possibilité.
</p>

<div id="ex-tnd"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "P ou non P",
            "rule": "tnd",
            "refs": []
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-tnd"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 1 est démontrée
    en utilisant la règle d'inférence <i>Principe du tiers exclu</i>.
</p>

<h4>Raisonnement par l'absurde</h4>

<p>
    La règle d'inférence <i>Raisonnement par l'absurde</i>
    permet de démontrer une proposition de la forme <code>p</code>,
    à partir d'une sous-preuve qui aboutit à une contradiction
    en admettant de l'hypothèse provisoire <code>non p</code>.
</p>

<p>
    La règle est similaire à la règle d'inférence <i>Introduction de <code>non</code></i>,
    mais elle permet de démontrer une proposition <code>p</code> au lieu de <code>non p</code>.
</p>

<p>
    On appelle aussi cette règle <i>réduction à l'absurde</i>.
    On admet qu'une proposition est vraie parce que sa négation est fausse.
</p>

<div id="ex-raa"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "non A",
            "rule": "assumption",
            "refs": []
            },
            "parts": [],
            "conclusion": {
            "type": "line",
            "expr": "faux",
            "rule": "hypothesis",
            "refs": []
            }
        },
        {
            "type": "line",
            "expr": "A",
            "rule": "raa",
            "refs": [
            "1-2"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-raa"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 3 est démontrée
    en utilisant la règle d'inférence <i>Raisonnement par l'absurde</i>
    à partir de la sous-preuve des lignes 1-2.
    Cette sous-preuve prend l'hypothèse <code>non A</code> et
    aboutit à une contradiction.
</p>

<h4>Élimination de la double négation</h4>

<p>
    Finalement, la règle d'inférence <i>Élimination de la double négation</i>
    permet de démontrer une proposition de la forme <code>p</code>,
    à partir d'une proposition de la forme <code>non (non p)</code>.
    La règle stipule que quelque chose d'irréfutable est vrai.
</p>


<div id="ex-notNotE"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "line",
            "expr": "non non A",
            "rule": "hypothesis",
            "refs": []
        },
        {
            "type": "line",
            "expr": "A",
            "rule": "notNotE",
            "refs": [
            "1"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-notNotE"), {
        static: true,
        menu: false,
    });
})();
</script>

<p>
    Dans l'exemple ci-dessus, la ligne 2 est démontrée
    en utilisant la règle d'inférence <i>Élimination de la double négation</i>
    à partir de la ligne 1.
</p>

<h3>Exemple de preuve</h3>

<p>
    Pour illustrer l'utilisation des règles d'inférence
    en déduction naturelle, nous allons démontrer une des lois de De Morgan,
    à savoir l'équivalence entre <code>non (A et B)</code> et <code>(non A) ou (non B)</code>.
</p>

<div id="ex-DeMorgan"></div>
<script type="text/javascript">
(function() {
    const proof = logicQuestions.Proof.fromJSON([
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "non (A et B)",
            "rule": "assumption",
            "refs": []
            },
            "parts": [
            {
                "type": "line",
                "expr": "A ou non A",
                "rule": "tnd",
                "refs": []
            },
            {
                "type": "subproof",
                "assumption": {
                "type": "line",
                "expr": "A",
                "rule": "assumption",
                "refs": []
                },
                "parts": [
                {
                    "type": "subproof",
                    "assumption": {
                    "type": "line",
                    "expr": "B",
                    "rule": "assumption",
                    "refs": []
                    },
                    "parts": [
                    {
                        "type": "line",
                        "expr": "A et B",
                        "rule": "andI",
                        "refs": [
                        "3",
                        "4"
                        ]
                    }
                    ],
                    "conclusion": {
                    "type": "line",
                    "expr": "faux",
                    "rule": "notE",
                    "refs": [
                        "1",
                        "5"
                    ]
                    }
                },
                {
                    "type": "line",
                    "expr": "non B",
                    "rule": "notI",
                    "refs": [
                    "4-6"
                    ]
                }
                ],
                "conclusion": {
                "type": "line",
                "expr": "non A ou non B",
                "rule": "orI2",
                "refs": [
                    "7"
                ]
                }
            },
            {
                "type": "subproof",
                "assumption": {
                "type": "line",
                "expr": "non A",
                "rule": "assumption",
                "refs": []
                },
                "parts": [],
                "conclusion": {
                "type": "line",
                "expr": "non A ou non B",
                "rule": "orI1",
                "refs": [
                    "9"
                ]
                }
            }
            ],
            "conclusion": {
            "type": "line",
            "expr": "non A ou non B",
            "rule": "orE",
            "refs": [
                "2",
                "3-8",
                "9-10"
            ]
            }
        },
        {
            "type": "line",
            "expr": "non (A et B) implique non A ou non B",
            "rule": "implI",
            "refs": [
            "1-11"
            ]
        },
        {
            "type": "subproof",
            "assumption": {
            "type": "line",
            "expr": "non A ou non B",
            "rule": "assumption",
            "refs": []
            },
            "parts": [
            {
                "type": "subproof",
                "assumption": {
                "type": "line",
                "expr": "non A",
                "rule": "assumption",
                "refs": []
                },
                "parts": [
                {
                    "type": "subproof",
                    "assumption": {
                    "type": "line",
                    "expr": "A et B",
                    "rule": "assumption",
                    "refs": []
                    },
                    "parts": [
                    {
                        "type": "line",
                        "expr": "A",
                        "rule": "andE1",
                        "refs": [
                        "15"
                        ]
                    }
                    ],
                    "conclusion": {
                    "type": "line",
                    "expr": "faux",
                    "rule": "notE",
                    "refs": [
                        "14",
                        "16"
                    ]
                    }
                }
                ],
                "conclusion": {
                "type": "line",
                "expr": "non (A et B)",
                "rule": "notI",
                "refs": [
                    "15-17"
                ]
                }
            },
            {
                "type": "subproof",
                "assumption": {
                "type": "line",
                "expr": "non B",
                "rule": "assumption",
                "refs": []
                },
                "parts": [
                {
                    "type": "subproof",
                    "assumption": {
                    "type": "line",
                    "expr": "A et B",
                    "rule": "assumption",
                    "refs": []
                    },
                    "parts": [
                    {
                        "type": "line",
                        "expr": "B",
                        "rule": "andE2",
                        "refs": [
                        "20"
                        ]
                    }
                    ],
                    "conclusion": {
                    "type": "line",
                    "expr": "faux",
                    "rule": "notE",
                    "refs": [
                        "19",
                        "21"
                    ]
                    }
                }
                ],
                "conclusion": {
                "type": "line",
                "expr": "non (A et B)",
                "rule": "notI",
                "refs": [
                    "20-22"
                ]
                }
            }
            ],
            "conclusion": {
            "type": "line",
            "expr": "non (A et B)",
            "rule": "orE",
            "refs": [
                "13",
                "14-18",
                "19-23"
            ]
            }
        },
        {
            "type": "line",
            "expr": "non A ou non B implique non (A et B)",
            "rule": "implI",
            "refs": [
            "13-24"
            ]
        },
        {
            "type": "line",
            "expr": "non (A et B) ssi non A ou non B",
            "rule": "iffI",
            "refs": [
            "12",
            "25"
            ]
        }
    ]);

    setUpFitch(proof, document.getElementById("ex-DeMorgan"), {
        static: true,
        menu: false,
    });
})();
</script>

<h3>Complétude et correction</h3>

<p>
    Prises ensemble, les règles qui forment la déduction naturelles
    permettent de démontrer certaines propositions.
    De manière intéressante, ce système de règles obéit à deux propriétés très importantes :
    <ol>
        <li>
            <i>La complétude :</i>
            Chaque proposition valide, chaque tautologie, peut être démontrée à l'aide de ces règles.
            Toute proposition valide peut être démontrée.
        </li>
        <li>
            <i>La correction :</i>
            Chaque démonstration est correcte, c'est-à-dire que si l'on suit les règles
            alors toute proposition démontrée est valide.
            Chaque proposition prouvée est bel et bien une tautologie.
        </li>
    </ol>
    Ces deux propriétés sont appelées <i>complétude et correction</i>.
    Elles établissent que la déduction naturelle est une façon assurée et
    correcte de démontrer la validité d'une proposition.
</p>
<p>
    La propriété de complétude a été prouvée par
    le mathématicien suisse <a href="https://fr.wikipedia.org/wiki/Paul_Bernays">Paul Bernays</a>.
</p>


