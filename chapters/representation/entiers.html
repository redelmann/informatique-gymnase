---
title: Représentation des entiers
order: 1
---

<p>
    Dans le chapitre précédent, nous avons vu comment
    représenter des entiers en base 2, c'est-à-dire
    en utilisant uniquement les chiffres <code>0</code> et <code>1</code>,
    c'est-à-dire les bits.
</p>

<p>
    La représentation des entiers en base 2 
    est à la base de beaucoup de techniques
    utilisées pour représenter de l'information.
    Cependant la base 2 n'est pas à proprement parler
    un code. Comme nous l'avons vu à la section précédente,
    un code permet de représenter uniquement un ensemble <b>fini</b> de valeurs.
    Or, la représentation des entiers en base 2
    permet de représenter un nombre infini de valeurs, à savoir
    tous les entiers positifs.
</p>

<p>
    Dans cette section, nous allons regarder
    comment représenter des entiers en utilisant
    des codes, et plus précisément des codes à longueur fixe.
    Nous allons voir que ces codes sont limités
    dans le nombre de valeurs qu'ils peuvent représenter.
    On appelle le <i>domaine de représentation</i> d'un code
    l'ensemble des valeurs qu'il peut représenter.
</p>

<h3>Nombres binaires à longueur fixe</h3>

<p>
    Commençons par regarder comment représenter des entiers
    positifs ou nuls en utilisant un code à longueur fixe.
    Pour représenter des entiers en utilisant un code à longueur fixe,
    on doit tout d'abord se décider sur la longueur <i>n</i> des mots
    de code. La longueur choisie détermine quels entiers peuvent être
    représentés par le code.
</p>

$remark$
<p>
    En pratique, les longueurs les plus courantes sont 8, 16, 32 et 64 bits.
    Ces longueurs sont des multiples de 8 bits, ce qui n'est
    pas une coïncidence. En effet, l'octet (groupe de 8 bits)
    est l'unité de base de stockage de l'information dans
    les ordinateurs.
</p>
$endremark$

<p>
    Une fois la taille <i>n</i> choisie,
    pour chaque nombre, on calcule sa représentation en base 2
    et on complète avec des zéros à gauche jusqu'à obtenir
    un mot de code de longueur <i>n</i>.
    On obtient ainsi un code à longueur fixe.
    Pour être technique, appellera ce code le <i>code binaire naturel de longueur </i> n.
    Ci-dessous est présenté le code binaire naturel de longeur 4,
    qui permet de représenter les entiers de 0 à 15.
</p>

<table class="code-table code-fixed">
    <tr>
        <th>Nombre</th>
        <th>Mot de code</th>
    </tr>
    <tr>
        <td>0</td>
        <td>0000</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0001</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0010</td>
    </tr>
    <tr>
        <td>3</td>
        <td>0011</td>
    </tr>
    <tr>
        <td>…</td>
        <td>…</td>
    </tr>
    <tr>
        <td>14</td>
        <td>1110</td>
    </tr>
    <tr>
        <td>15</td>
        <td>1111</td>
    </tr>
</table>

<p>
    Le <i>domaine de représentation</i> d'un tel code est l'ensemble des entiers
    compris entre 0 et 2<sup>n</sup> - 1. Cela signifie que le code ne peut
    représenter que les entiers compris dans cet intervalle.
    Toute valeur en dehors de cet intervalle ne peut pas être représentée
    par le code.
    En effet, les nombres plus grands ou égaux à 2<sup>n</sup> ne peuvent pas
    être représentés car ils nécessiteraient un mot de code de longueur supérieure à <i>n</i>
    selon cette méthode.
</p>

<p>
    Comme nous l'avons déjà mentionné, un code est forcément
    limité dans le nombre de valeur qu'il peut représenter.
    Dans le cas d'un code binaire de longueur fixe <i>n</i>,
    le nombre de valeurs représentables est au maximum de 2<sup>n</sup>.
</p>

<h3>Complément à 2</h3>

<p>
    Comme nous l'avons vu lors du chapitre précédent
    sur l'architecture des ordinateurs,
    la méthode du complément à 2
    permet de représenter des entiers négatifs et positifs
    en utilisant un code à longueur fixe.
    Ci-dessous est présenté le 
    code à longueur fixe de longueur 4
    pour le complément à 2
    sous la forme d'un tableau.
</p>

<table class="code-table code-fixed">
    <tr>
        <th>Nombre</th>
        <th>Mot de code</th>
    </tr>
    <tr>
        <td>-8</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>-7</td>
        <td>1001</td>
    </tr>
    <tr>
        <td>-6</td>
        <td>1010</td>
    </tr>
    <tr>
        <td>-5</td>
        <td>1011</td>
    </tr>
    <tr>
        <td>-4</td>
        <td>1100</td>
    </tr>
    <tr>
        <td>-3</td>
        <td>1101</td>
    </tr>
    <tr>
        <td>-2</td>
        <td>1110</td>
    </tr>
    <tr>
        <td>-1</td>
        <td>1111</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0000</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0001</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0010</td>
    </tr>
    <tr>
        <td>3</td>
        <td>0011</td>
    </tr>
    <tr>
        <td>4</td>
        <td>0100</td>
    </tr>
    <tr>
        <td>5</td>
        <td>0101</td>
    </tr>
    <tr>
        <td>6</td>
        <td>0110</td>
    </tr>
    <tr>
        <td>7</td>
        <td>0111</td>
    </tr>
</table>

<p>
    Le domaine de représentation du complément à 2 sur <i>n</i> bits
    est l'ensemble des entiers relatifs compris entre -2<sup>n-1</sup> et 2<sup>n-1</sup> - 1,
    ce qui correspond à 2<sup>n</sup> valeurs différentes.
    Notez que le code permet de représenter un nombre négatif de plus que de nombre positif.
    En effet, la valeur 0 est représentée par le mot de code <code>000…0</code>
    qui commence par un zéro, et
    qui donc est donc groupé avec les nombres positifs.
</p>

$remark$
<p>
    Comme nous l'avons déjà vu, pour obtenir le mot de code
    qui correspond à un nombre <i>-k</i>, il suffit de prendre le
    mot de code de <i>k</i>, d'en inverser tous les bits
    et d'y additionner 1.
</p>
<p>
    Cette méthode fonctionne pour tous les nombres relatifs représentables
    par le code, à l'exception de -2<sup>n-1</sup>, où <i>n</i> est la longueur du code.
    Le mot de code de 2<sup>n-1</sup> est donc <code>100…0</code>.
    Si on inverse tous les bits du mot de code puis on ajoute 1,
    on retombe sur le même mot de code.
    À noter que cela n'est pas surprenant,
    car 2<sup>n-1</sup> n'est pas représentable dans ce code.
</p>
$endremark$

<p>
    Comme nous l'avons vu dans le chapitre précédent,
    cette méthode de représentation des nombres relatifs
    est très pratique pour les ordinateurs.
    En effet, les opérations arithmétiques sur les nombres relatifs
    peuvent être réalisées en utilisant les mêmes opérations
    que pour les nombres positifs.
</p>

$selfcheck$
<p>
    Un code binaire à longueur fixe de longueur 4 peut représenter au maximum
    <select class="self-pick">
        <option>2</option>
        <option>3</option>
        <option>4</option>
        <option>7</option>
        <option>8</option>
        <option>15</option>
        <option data-correct>16</option>
        <option>31</option>
        <option>32</option>
    </select> valeurs différentes, alors que pour un code binaire à longueur fixe de longueur 5, le nombre maximum de valeurs différentes est de
    <select class="self-pick">
        <option>2</option>
        <option>3</option>
        <option>4</option>
        <option>7</option>
        <option>8</option>
        <option>15</option>
        <option>16</option>
        <option>31</option>
        <option data-correct>32</option>
    </select>.
</p>
<p>
    Lorsque la longueur d'un code binaire de longeur fixe augmente de 1,
    le nombre de valeurs différentes qu'il peut potentiellement représenter
    <select class="self-pick">
        <option>augmente de 1</option>
        <option>augmente de 2</option>
        <option data-correct>double</option>
        <option>triple</option>
        <option>quadruple</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Étant donné une longueur de code fixée à 4 bits,
    la méthode du complément à 2 permet de représenter
    les nombres
    <select class="self-pick">
        <option>rationels</option>
        <option data-correct>relatifs</option>
        <option>à virgule</option>
    </select>
    compris entre <select class="self-pick">
        <option>-16</option>
        <option>-15</option>
        <option data-correct>-8</option>
        <option>-7</option>
        <option>-4</option>
        <option>-3</option>
        <option>-1</option>
        <option>0</option>
        <option>1</option>
        <option>3</option>
        <option>4</option>
        <option>7</option>
        <option>8</option>
        <option>15</option>
        <option>16</option>
    </select> et <select class="self-pick">
        <option>-16</option>
        <option>-15</option>
        <option>-8</option>
        <option>-7</option>
        <option>-4</option>
        <option>-3</option>
        <option>-1</option>
        <option>0</option>
        <option>1</option>
        <option>3</option>
        <option>4</option>
        <option data-correct>7</option>
        <option>8</option>
        <option>15</option>
        <option>16</option>
    </select>.
</p>
$endselfcheck$

<p>
    Dans la section suivante, nous allons voir comment représenter
    des caractères comme des lettres, chiffres et autres symboles
    en utilisant des codes binaires.
</p>

$master$
<p>
    Avant de poursuivre, assurez-vous de pouvoir :
</p>

<ul>
    <li>Lire et écrire des nombres entiers positifs en binaire naturel de longueur quelconque.</li>
    <li>Lire et écrire des nombres entiers relatifs en binaire sur un nombre fixe de bits avec la
        méthode du complément à deux.</li>
    <li>Déterminer le domaine de représentation selon le code binaire naturel
        de longueur donnée.</li>
    <li>Déterminer le domaine de représentation selon la méthode du complément à deux
        pour un nombre donné de bits.</li>
</ul>
$endmaster$