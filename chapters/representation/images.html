---
title: Représentation des images
order: 5
unfinished: true
---

<p>
    Dans cette section, nous allons
    étudier différents formats de fichier
    pour représenter des images.
</p>

<p>
    Les formats de représentation des images
    sont nombreux et variés.
    Ils se classent en deux grandes catégories :
    les formats d'images <i>matricielles</i> et
    les formats d'images <i>vectorielles</i>.
</p>

<h2>Images matricielles</h2>

<p>
    Une image matricielle est une image
    qui est représentée par une <i>matrice</i> de <i>pixels</i>.
    Une matrice est simplement un tableau à deux dimensions.
    Chaque case du tableau contient un pixel,
    et chaque pixel est représenté par une couleur.
</p>

$remark$
<p>
    Le terme <i>pixel</i> est une abréviation de <i lang="en">picture element</i>,
    qui signifie <i>élément d'image</i> en anglais.
</p>
$endremark$

<p>
    Dans cette section, nous allons regarder un format
    en particulier : le format BMP.
</p>

<style>
.bmp-editor {
    width: 100%;
    padding-bottom: 20px;
}

.bmp-editor input {
    width: 2em;
    height: 1em;
    border: none;
    background-color: white;
    text-align: center;
    font-size: 1em;
    font-family: monospace;
    text-transform: uppercase;
    padding: 0;
    margin: 0;
    box-sizing: border-box;
}

.bmp-editor input:focus {
    outline: none;
}

.bmp-editor input:disabled {
    background-color: #eee;
}

.bmp-preview {
    width: 100%;
}

.bmp-preview a {
    display: block;
    text-align: center;
    font-size: 1em;
    text-decoration: underline;
    color: blue;
    margin-top: 10px;
    cursor: pointer;
}

.bmp-preview img {
    display: block;
    margin: auto;
    width: 80%;
    height: auto;
    image-rendering: pixelated;
    border: 1px solid black;
}
</style>

<h3>Image 4 par 4 pixels</h3>

<div class="cols-2" id="bmp-4-4"></div>

$tryout$
<p>
    Dans l'éditeur hexadécimal ci-dessous,
    modifiez les octets de l'image pour compléter le damier.
    Les octets d'en-tête ne sont pas modifiables.
</p>
$endtryout$

<h3>Image 8 par 8 pixels</h3>

<div class="cols-2" id="bmp-8-8"></div>

$tryout$
<p>
    L'image ci-dessus est une image 8 par 8 pixels.
    Modifiez les octets de l'image pour
    dessinez un motif de votre choix.
</p>
$endtryout$

<script type="text/javascript">
let next_bmp_id = 0;
function setup_bmp_editor(container, header_bytes, pixels_bytes) {
    const id = next_bmp_id++;
    // If pixel_bytes is a number, create an array of that size
    if (typeof pixels_bytes === "number") {
        pixels_bytes = new Array(pixels_bytes * 3).fill(0xff);
    }
    const saved_pixels = sessionStorage.getItem("bmp-" + id + "-pixels");
    if (saved_pixels) {
        pixels_bytes = saved_pixels.split(",").map(function(number) {
            return parseInt(number);
        });
    }
    const pixels = pixels_bytes.length / 3;
    const editor = document.createElement("div");
    editor.classList.add("bmp-editor");
    const preview = document.createElement("div");
    preview.classList.add("bmp-preview");
    const image = document.createElement("img");
    const link = document.createElement("a");
    link.textContent = "Télécharger";
    preview.appendChild(image);
    preview.appendChild(link);
    container.appendChild(editor);
    container.appendChild(preview);

    const bytes = new Uint8Array(header_bytes.length + pixels_bytes.length);

    link.addEventListener("click", function() {
        const blob = new Blob([bytes], {type: "image/bmp"});
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = "image.bmp";
    });

    for (let i = 0; i < header_bytes.length; i++) {
        bytes[i] = header_bytes[i];
    }

    for (let i = 0; i < pixels_bytes.length; i++) {
        const j = header_bytes.length + i;
    
        bytes[j] = pixels_bytes[i];
    }

    for (let i = 0; i < bytes.length; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.size = 2;
        input.maxLength = 2;
        input.value = byte_to_hex(bytes[i]);
        input.pattern = "[0-9a-fA-F]{2}";
        input.addEventListener("focus", function() {
            input.select();
        })
        input.addEventListener("input", function() {
            bytes[i] = byte_from_hex(input.value);
            update_preview();
            if (input.value.length == 2) {
                const next = input.nextElementSibling;
                if (next) {
                    next.focus();
                }
            }
        });
        input.addEventListener("blur", function() {
            input.value = byte_to_hex(bytes[i]);
            sessionStorage.setItem("bmp-" + id + "-pixels", bytes.slice(header_bytes.length).join(","));
        });
        input.addEventListener("keydown", function(event) {
            if (input.selectionStart == 0 && event.key == "ArrowLeft") {
                const previous = input.previousElementSibling;
                if (previous) {
                    console.log("previous");
                    previous.focus();
                }
                event.preventDefault();
                return false;
            }
            if (input.selectionEnd == 2 && event.key == "ArrowRight") {
                const next = input.nextElementSibling;
                if (next) {
                    console.log("next");
                    next.focus();
                }
                event.preventDefault();
                return false;
            }
        });
        if (i < header_bytes.length) {
            input.disabled = true;
        }
        editor.appendChild(input);
    }

    function byte_to_hex(byte) {
        const hex = byte.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }

    function byte_from_hex(hex) {
        return parseInt(hex, 16) & 0xff;
    }

    function base64_data() {
        const base64 = btoa(String.fromCharCode.apply(null, bytes));
        return "data:image/bmp;base64," + base64;
    }

    function update_preview() {
        image.src = base64_data();
    }

    update_preview();
}

(function(){

    const header_bytes_4_4 = [
        0x42, 0x4d, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x13, 0x0b,
        0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];

    const pixels_bytes_4_4 = [
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ];

    const header_bytes_8_8 = [
        0x42, 0x4d, 0xf6, 0x00, 0x0c, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xC0, 0x00, 0x0c, 0x00, 0x13, 0x0b,
        0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];

    setup_bmp_editor(document.getElementById("bmp-4-4"), header_bytes_4_4, pixels_bytes_4_4);
    setup_bmp_editor(document.getElementById("bmp-8-8"), header_bytes_8_8, 64);
})();
</script>



<h2>Images vectorielles</h2>

<p>
    Une autre façon de représenter des images
    consiste à décrire les formes géométriques
    qui composent l'image.
    On parle dans ce cas d'<i>images vectorielles</i>.
</p>

$tryout$
<p>
    Ci-dessous vous trouverez la même image représentée
    dans deux formats différents : un format matriciel
    et un format vectoriel.
    Utilisez la barre de zoom pour voir ce qui se passe
    lorsque vous zoomez sur l'image en version vectorielle
    et comparez avec ce qui se passe lorsque vous zoomez
    sur l'image en version matricielle.
</p>

<style>

.image-container {
    position: relative;
    padding-bottom: 20px;
    display: flex;
    flex-direction: column;
    width: 100%;
    overflow: hidden;
}

.image-zoomable {
    overflow: scroll;
    overscroll-behavior-x: none;
    width: fit-content;
    max-width: 100%;
    height: 260px;
    margin: auto;
    flex: 1 1 auto;
}

.image-zoomable svg, .image-zoomable img {
    transform-origin: 0 0;
    image-rendering: pixelated;
    user-select: none;
    cursor: grab;
    margin: auto;

}

.image-controls {
    flex: 0 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 1em;
    flex-direction: row;
    gap: 1em;
}

.image-controls label {
    flex-grow: 0;
}

.image-controls input {
    flex-grow: 1;
}

.image-wrapper {
    width: 250px;
    height: 250px;
}
</style>

<div class="cols-2">
    <div class="image-container">
        <div class="image-zoomable">
            <div class="image-wrapper">
                <svg width="250" height="250">
                    <defs>
                        <linearGradient spreadMethod="pad" y2="0" x2="0" y1="0.68439" x1="0.41797" id="svg_3">
                            <stop offset="0" stop-opacity="0.99609" stop-color="#e81212"/>
                            <stop offset="1" stop-opacity="0.99609" stop-color="#ff7f00"/>
                        </linearGradient>
                        <linearGradient spreadMethod="pad" y2="0" x2="0" y1="0.68439" x1="0.41797" id="svg_4">
                            <stop offset="0" stop-opacity="0.99219" stop-color="#0e822f"/>
                            <stop offset="1" stop-opacity="0.99219" stop-color="#40c456"/>
                        </linearGradient>
                        <linearGradient y2="0" x2="1" y1="0" x1="0" id="svg_11">
                            <stop offset="0" stop-opacity="0.99609" stop-color="#f2cc0e"/>
                            <stop offset="1" stop-opacity="0.99609" stop-color="#d1c11b"/>
                        </linearGradient>
                    </defs>
                    <g>
                        <polygon transform="rotate(-8.43362 117.507 88.5455)" id="svg_20" points="45,72 100,72 118,20 135,72 190,72 145,105 162,158 118,125 73,158 90,105 45,72" stroke-width="2" stroke="#8c7c04" fill="url(#svg_11)"/>
                        <ellipse stroke-width="2" stroke="#7f0000" ry="42.5" rx="43" id="svg_1" cy="146.49865" cx="141.50149" fill="url(#svg_3)"/>
                        <polygon transform="rotate(15.4538 138 106.499)" stroke-width="2" stroke="#054927" id="svg_5" points="137,81 125,123 136,132 151,115 137,81" opacity="1" fill="url(#svg_4)"/>
                        <path stroke="#492605" id="svg_6" d="m128.76698,133.33239l-18.76685,-34.36765c-2.33333,-4.39706 11.4233,-6.63235 11.4233,-6.63235c10.5,37.16667 8.1595,30.14706 8.1595,29.54412c3.5,9.60294 16.319,-9.64706 -0.81595,11.45588z" opacity="1" stroke-width="2" fill="#7f3f00"/>
                        <text transform="rotate(-17.6739 157.385 198.004)" font-weight="normal" xml:space="preserve" text-anchor="start" font-family="'Helvetica'" font-size="24" id="svg_21" y="206.50364" x="72.00257" stroke-width="0" stroke="#8c7c04" fill="#000000">sur les pommes</text>
                        <text transform="rotate(-17.8376 55.502 201.837)" xml:space="preserve" text-anchor="start" font-family="'Helvetica'" font-size="36" id="svg_26" y="214.58887" x="9.99581" stroke="#f72e2e" fill="#e80000">-20%</text>
                    </g>
                </svg>
            </div>
        </div>
        <div class="image-controls">
            <input type="range" min="1" max="20" step="0.5" value="1" class="zoom-range" id="zoom-range-1" />
            <label for="zoom-range-1">100%</label>
        </div>
    </div>
    <div class="image-container">
        <div class="image-zoomable">
            <div class="image-wrapper">
                <img src="/docs/png/pommes.png" draggable="false" />
            </div>
        </div>
        <div class="image-controls">
            <input type="range" min="1" max="20" step="0.5" value="1" class="zoom-range" id="zoom-range-2" />
            <label for="zoom-range-2">100%</label>
        </div>
    </div>
</div>

<script type="text/javascript">
(function() {
    const containers = document.querySelectorAll('.image-container');
    const zoomables = [];
    const images = [];
    const wrappers = [];
    const ranges = [];
    const labels = [];
    for (let container of containers) {
        const zoomable = container.querySelector('.image-zoomable');
        zoomables.push(zoomable);
        const image = zoomable.querySelector('svg, img');
        images.push(image);
        const wrapper = zoomable.querySelector('.image-wrapper');
        wrappers.push(wrapper);
        const startWidth = 250;
        const startHeight = 250;

        const controls = container.querySelector('.image-controls');
        const range = controls.querySelector('.zoom-range');
        ranges.push(range);
        const label = controls.querySelector('label');
        labels.push(label);
        let zoom = 1;
        range.addEventListener('input', function() {
            const value = range.value;

            const scrollLeft = zoomable.scrollLeft;
            const scrollTop = zoomable.scrollTop;

            let focusLeft = scrollLeft + zoomable.clientWidth / 2;
            let focusTop = scrollTop + zoomable.clientHeight / 2;

            console.log(focusLeft, focusTop);

            for (i of images) {
                i.style.transform = `scale($${value})`;
            }
            for (w of wrappers) {
                w.style.width = `$${startWidth * value}px`;
                w.style.height = `$${startHeight * value}px`;
            }
            for (l of labels) {
                l.textContent = `$${value * 100}%`;
            }
            for (r of ranges) {
                r.value = value;
            }

            focusLeft *= value / zoom;
            focusTop *= value / zoom;

            for (z of zoomables) {
                z.scrollLeft = focusLeft - z.clientWidth / 2;
                z.scrollTop = focusTop - z.clientHeight / 2;
            }

            zoom = value;
        });

        // Moving around with the mouse
        let mouseDown = false;
        let lastX = 0;
        let lastY = 0;

        zoomable.addEventListener("scroll", function(event) {
            console.log('scroll', event);
            if (mouseDown) {
                event.preventDefault();
            }
            else {
                const scrollLeft = zoomable.scrollLeft;
                const scrollTop = zoomable.scrollTop;
                for (z of zoomables) {
                    z.scrollLeft = scrollLeft;
                    z.scrollTop = scrollTop;
                }
            }
        }, false);

        zoomable.addEventListener('mousedown', function(event) {
            mouseDown = true;
            lastX = event.clientX;
            lastY = event.clientY;
            document.body.classList.add('grabbing');
        });

        document.addEventListener('mouseup', function(event) {
            mouseDown = false;
            document.body.classList.remove('grabbing');
        });

        document.addEventListener('mousemove', function(event) {
            if (document.hasFocus() && mouseDown) {
                const deltaX = event.clientX - lastX;
                const deltaY = event.clientY - lastY;
                for (z of zoomables) {
                    z.scrollLeft -= deltaX;
                    z.scrollTop -= deltaY;
                }
                lastX = event.clientX;
                lastY = event.clientY;
            }
        });

        // Ungrab when the document loses focus
        document.addEventListener('blur', function(event) {
            mouseDown = false;
            document.body.classList.remove('grabbing');
        });
    }
})();
</script>

$endtryout$

<p>
    Un avantage des images vectorielles
    est qu'elles sont redimensionnables
    sans perte de qualité.
    En effet, les formes géométriques
    qui composent l'image peuvent être
    mises à différentes échelles sans perdre
    de détails ou de précision.
</p>