---
title: Représentation des images
order: 5
---

<p>
    Dans cette section, nous allons
    nous intéresser à la question de la
    représentation des images.
    Comment décrire une image à l'aide
    de séquences de bits ?
    Dans la section précédente, nous avons
    comment représenter des couleurs en utilisant
    des codes binaires, notamment le code RVB.
    Dans cette section, nous allons voir comment
    représenter des images en utilisant
    différents formats de fichiers.
</p>

<p>
    Les formats de représentation des images
    sont nombreux et variés.
    Ils se classent cependant en deux grandes catégories :
    les formats d'images <i>matricielles</i> et
    les formats d'images <i>vectorielles</i>.
</p>

<style>
.img-ex {
    margin: 0 auto;
    display: block;
    border: 1px solid #000;
    image-rendering: pixelated;
}
</style>

<div class="cols-2">

    <div>
        <figure>
            <img src="/docs/png/arbre.png" alt="Photographie d'un arbre." class="img-ex" />
            <figcaption>Une image matricielle.</figcaption>
        </figure>

        <p>
            Les images matricielles sont les plus couramment utilisées.
            Dans une image matricielle, l'image est représentée
            par une matrice (une grille) de cellules colorées que l'on appelle
            des <i>pixels</i>.
            Ce type d'image est très utilisé pour les photographies
            par exemple.
        </p>
    </div>

    <div>
        <figure>
            <svg width="250" height="250" class="img-ex" xmlns="http://www.w3.org/2000/svg">
                <g id="Layer_1">
                    <ellipse stroke="#7f0000" ry="77.5" rx="77.5" id="svg_2_1" cy="94" cx="95" fill="url(#svg_2_2)"/>
                    <ellipse ry="55.5" rx="55.5" id="svg_2_8" cy="174.5" cx="167" stroke="#204cbc" fill="url(#svg_2_10)"/>
                    <ellipse id="svg_2_11" cy="273" cx="172.5" stroke="#204cbc" fill="url(#svg_2_10)"/>
                    <ellipse id="svg_2_13" cy="265" cx="273.5" stroke="#204cbc" fill="url(#svg_2_10)"/>
                    <path transform="rotate(17.8063 165.434 171.385)" stroke="#bf5f00" stroke-width="0" id="svg_2_3" d="m138.51143,165.34737l20.56739,0l6.35548,-19.53893l6.35549,19.53893l20.56739,0l-16.63934,12.07559l6.35581,19.53893l-16.63935,-12.07592l-16.63934,12.07592l6.35581,-19.53893l-16.63934,-12.07559z" fill="url(#svg_2_5)"/>
                    <path transform="rotate(-62.8554 90.2375 92.75)" id="svg_2_15" d="m59.2375,76.78184l15.03184,-15.03184l15.96809,15.96796l15.96809,-15.96796l15.03198,15.03184l-15.96809,15.96809l15.96809,15.96809l-15.03198,15.03198l-15.96809,-15.96809l-15.96809,15.96809l-15.03184,-15.03198l15.96796,-15.96809l-15.96796,-15.96809z" stroke-width="0" stroke="#bf5f00" fill="url(#svg_2_16)"/>
                </g>
                <defs>
                    <radialGradient cy="0.37579" cx="0.37109" spreadMethod="pad" id="svg_2_2">
                        <stop offset="0" stop-opacity="0.99609" stop-color="#ff5656"/>
                        <stop offset="1" stop-opacity="0.99609" stop-color="#bf0000"/>
                    </radialGradient>
                    <radialGradient r="0.5" cy="0.37579" cx="0.37109" spreadMethod="pad" id="svg_2_5">
                        <stop offset="0" stop-opacity="0.99609" stop-color="#ffaa56"/>
                        <stop offset="1" stop-opacity="0.99609" stop-color="#ff7f00"/>
                    </radialGradient>
                    <radialGradient r="0.5" cy="0.26642" cx="0.28125" spreadMethod="pad" id="svg_2_10">
                        <stop offset="0" stop-opacity="0.99609" stop-color="#56aaff"/>
                        <stop offset="1" stop-opacity="0.99609" stop-color="#005fbf"/>
                    </radialGradient>
                    <radialGradient r="0.63394" cy="0.37579" cx="0.37109" spreadMethod="pad" id="svg_2_16">
                        <stop offset="0" stop-opacity="0.98828" stop-color="#ffffff"/>
                        <stop offset="1" stop-opacity="0.99219" stop-color="#cccccc"/>
                    </radialGradient>
                </defs>
            </svg>
            <figcaption>Une image vectorielle.</figcaption>
        </figure>

        <p>
            Les images vectorielles quant à elles
            sont représentées par des formes géométriques
            (cercles, rectangles, courbes, etc.)
            décrites par des équations mathématiques.
            On utilise souvent ce type d'image pour les logos par exemple,
            qui sont généralement composés de formes simples
            et déclinés dans plusieurs tailles.
        </p>
    </div>
</div>

<p>
    En première partie de cette section,
    nous allons nous intéresser aux images matricielles.
    Nous aborderons ensuite les images vectorielles
    dans la deuxième partie de la section.
</p>

<h2>Images matricielles</h2>

<p>
    Une image matricielle est une image
    qui est représentée par une <i>matrice</i> de <i>pixels</i>.
    Une matrice est simplement un tableau à deux dimensions, une grille.
    Chaque cellule du tableau contient ce qu'on appelle un <i>pixel</i>.
    Chaque pixel contient une couleur, généralement représentée par
    un code couleur comme le code RVB que nous avons vu
    dans la section précédente.
</p>

<p>
    Ces pixels ne sont pas toujours visibles à l'œil nu,
    il faut parfois zoomer sur l'image pour les voir.
</p>

<figure>
    <img src="/docs/png/matrice.png" alt="Une image matricielle" width="320" height="320" class="img-ex" />
    <figcaption>Zoom sur les pixels d'une image matricielle.</figcaption>
</figure>

$remark$
<p>
    Le terme <i>pixel</i> est une abréviation de <i lang="en">picture element</i>,
    qui signifie <i>élément d'image</i> en anglais.
</p>
$endremark$

<p>
    Les pixels d'une images matricielles sont organisés en un
    certain nombre de colonnes et de lignes.
    On parle de la <i>largeur</i> et de la <i>hauteur</i> de l'image.
    De manière formelle, on parle aussi de la <i>définition</i> de l'image
    pour désigner le nombre de pixels de l'image.
</p>

$example$
<p>
    Une image de 100 pixels de large
    et de 50 pixels de haut a une définition de 5000 pixels,
    parfois notée <i>100 par 50 pixels</i> ou encore <i>100×50 pixels</i>.
</p>
<p>
    De nos jours, les images obtenues avec les appareils photo numériques
    tels que ceux intégrés à nos téléphones portables
    ont une définition de plusieurs millions de pixels.
</p>
$endexample$

$remark$
<p>
    La définition d'une image n'est pas à confondre
    avec sa <i>résolution</i>.
    La résolution est le nombre de pixels
    par unité de longueur d'une image représentée sur un support physique
    (comme une feuille de papier ou un écran).
    On mesure généralement la résolution en <i>points par pouce</i>
    ou en <i>points par centimètre</i>.
    Au contraire de la définition, 
    la résolution dépend du support physique de l'image, pas de l'image en soit.
</p>

<p>
    À noter qu'on parle aussi de pixel pour désigner
    les points lumineux d'un écran.
    Un écran a donc une résolution que l'on pourrait mesurer.
    La résolution d'un écran relativement récent est généralement
    comprise entre quelques dizaines de points par centimètre
    (pour des écrans de télévision par exemple)
    à plus d'une centaine de points par centimètre
    (pour des écrans de téléphones portables par exemple).
</p>

<p>
    Pour afficher une image matricielle sur un écran,
    il n'est pas rare que les pixels de l'image ne correspondent pas
    directement aux pixels de l'écran.
    Plusieurs pixels de l'image peuvent être regroupés
    pour former un seul pixel de l'écran, ou au contraire,
    un seul pixel de l'image peut être étalé sur plusieurs pixels de l'écran.
</p>
$endremark$

<p>
    Une image représentée sous forme de fichier a aussi une taille
    en terme d'octets. Cette taille dépend de la définition de l'image,
    mais aussi du format de fichier utilisé.
    On utilise généralement le terme <i>poids</i> pour désigner la taille
    en octets d'une image ou plus généralement d'un fichier.
</p>

<p>
    Dans cette section, afin de nous intéresser dans plus de détails
    et de praticité aux images matricielles, nous allons aborder un format
    d'image matricielle en particulier : le format BMP.
</p>

<h3>Le format BMP</h3>

<p>
    Le format BMP (aussi appelé <i lang="en">bitmap</i>)
    est un format d'image matricielle
    relativement simple.
    Il s'agit d'un format de fichier binaire,
    c'est-à-dire que les données sont représentées
    directement par des bits.
</p>

<p>
    Ci-dessous est presentée une image
    de définition 8 par 8 pixels
    au format BMP
    ainsi que les octets qui la représentent.
    Les octets sont indiqués en hexadécimal,
    une notation que nous avons abordée dans la
    section sur les fichiers.
    Chaque octet est représenté par deux chiffres hexadécimaux.
    La séquence d'octets se lit de gauche à droite et de haut en bas.
</p>

<p>
    L'image représente un magnifique pot de fleurs en <a href="https://fr.wikipedia.org/wiki/Pixel_art">pixel art</a>.
</p>

<div class="cols-2" id="bmp-example"></div>

<p>
    Le fichier se compose de deux parties distinctes :
    l'<i>entête</i> et les pixels.
    La zone d'entête, représentée avec un fond gris
    ci-dessus, contient des informations sur l'image comme,
    par exemple,
    sa largeur et sa hauteur.
    Après l'entête arrivent les pixels.
    La zone de pixels, représentée avec un fond blanc,
    contient le code couleur de chaque pixel de l'image.
</p>

<p>
    Dans le format BMP, les pixels sont stockés
    dans l'ordre <i>de gauche à droite</i> et
    <i>de bas en haut</i>.
    Cela signifie que le premier pixel est celui
    en bas à gauche de l'image, le deuxième est
    celui à droite du premier, et ainsi de suite.
    Lorsque l'on arrive à la fin d'une ligne,
    on passe à la gauche de la ligne suivante, au dessus.
</p>

<p>
    Chaque pixel est représenté par trois octets.
    Dans le format BMP, on commence par un octet pour l'intensité du bleu,
    puis un octet pour l'intensité du vert, et enfin un octet pour l'intensité du rouge.
    L'ordre est inversé par rapport au code RVB que nous avons vu
    dans la section précédente, mais le principe reste le même.
</p>

$tryout$
<p>
    Dans l'éditeur hexadécimal ci-dessus,
    la zone des pixels de l'image est éditable.
    Essayez de modifier les octets pour changer les couleurs de l'image.
</p>
$endtryout$

<link rel="stylesheet" href="/css/bmp-editor.css" />

<h3>Image 4 par 4 pixels</h3>

<p>
    La définition d'une image a généralement une grande influence
    sur le poids du fichier.
    Ci-dessous est représentée une image de définition 4 par 4 pixels.
    Constatez que le poids du fichier est moindre par rapport à l'image
    de définition 8 par 8 pixels montrée plus haut.
</p>

<div class="cols-2" id="bmp-4-4"></div>

$tryout$
<p>
    Dans l'éditeur hexadécimal ci-dessus,
    modifiez les octets de l'image pour compléter le damier.
    Pour l'exemple, les octets d'en-tête ne sont pas modifiables,
    uniquement les octets de pixels.
</p>
$endtryout$

<script type="text/javascript" src="/js/bmp-editor.js"></script>

<script type="text/javascript">
(function(){

    const header_bytes_example = [
        0x42, 0x4D, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00,
        0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
        0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    ];

    const pixels_bytes_example = [
        0x33, 0xA0, 0x00, 0x03, 0xC1, 0x00, 0x33, 0xA0, 0x00, 0x2B, 0x66, 0xBC, 0x24, 0x5B, 0xA8, 0x24, 0x5B, 0xA8, 0x0A, 0x87, 0x00, 0x33, 0xA0, 0x00, 
        0x03, 0xC1, 0x00, 0x00, 0xED, 0x00, 0x00, 0xD8, 0x00, 0x2B, 0x66, 0xBC, 0x24, 0x5B, 0xA8, 0x24, 0x5B, 0xA8, 0x00, 0xD8, 0x00, 0x00, 0xED, 0x00, 
        0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0x3B, 0x8C, 0xFF, 0x37, 0x83, 0xF3, 0x37, 0x83, 0xF3, 0x37, 0x83, 0xF3, 0x30, 0x71, 0xD0, 0xFF, 0xF4, 0x62, 
        0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0x02, 0xC3, 0x00, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 
        0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0x00, 0x01, 0xD6, 0x11, 0xA0, 0x24, 0x11, 0xA0, 0x24, 0x41, 0xCE, 0x25, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 
        0xFF, 0xF4, 0x62, 0x00, 0x00, 0xF6, 0x43, 0xDF, 0xFF, 0x00, 0x00, 0xD6, 0xFF, 0xF4, 0x62, 0x33, 0xA1, 0x20, 0xF3, 0x7F, 0x2B, 0xFF, 0xF4, 0x62, 
        0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0x01, 0x00, 0xF6, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0x8A, 0x2F, 0x43, 0xDF, 0xFF, 0xF3, 0x7F, 0x2B, 
        0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0xF4, 0x62, 0xFF, 0x8A, 0x2F, 0xFF, 0xF4, 0x62
    ];

    const header_bytes_4_4 = [
        0x42, 0x4d, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x13, 0x0b,
        0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];

    const pixels_bytes_4_4 = [
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ];

    setup_bmp_editor(document.getElementById("bmp-example"), header_bytes_example, pixels_bytes_example, false);
    setup_bmp_editor(document.getElementById("bmp-4-4"), header_bytes_4_4, pixels_bytes_4_4, false);
})();
</script>

<h3>Logiciels de manipulation d'images matricielles</h3>

<p>
    En général, on n'écrira ou on ne modifiera pas directement des images matricielles
    dans un éditeur hexadécimal.
    La tâche serait bien trop fastidieuse.
    À la place, on utilisera un logiciel, un programme, pour réaliser cette tâche.
</p>

<p>
    Parmi les logiciels de manipulation d'images matricielles les plus connus, on peut citer :
</p>

<ul>
    <li>
        <a href="https://www.gimp.org/">GIMP</a> (GNU Image Manipulation Program), 
        un logiciel libre et gratuit, disponible sur Windows, Mac OS et Linux.
    </li>
    <li>
        <a href="https://www.adobe.com/fr/products/photoshop.html">Adobe Photoshop</a>, 
        un logiciel propriétaire, payant, disponible sur Windows et Mac OS.
    </li>
</ul>

<p>
    Dans le cadre de ce cours, nous verrons aussi comment manipuler des images matricielles
    avec le langage de programmation Python et la bibliothèque <a href="https://pillow.readthedocs.io/en/stable/">Pillow</a>.
</p>

$selfcheck$
<p>
    Les images matricielles sont représentées par
    <select class="self-pick">
        <option>des formes géométriques</option>
        <option data-correct>une matrice de pixels</option>
        <option>un ensemble de vecteurs</option>
        <option>un texte</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Pour désigner la taille en pixels d'une image matricielle,
    on utilise le terme de
    <select class="self-pick">
        <option>largeur</option>
        <option>hauteur</option>
        <option>poids</option>
        <option>résolution</option>
        <option data-correct>définition</option>
    </select>, alors que pour désigner la taille en octets d'une image matricielle
    on utilise le terme de
    <select class="self-pick">
        <option>largeur</option>
        <option>hauteur</option>
        <option data-correct>poids</option>
        <option>résolution</option>
        <option>définition</option>
    </select>.
</p>
$endselfcheck$


<h2>Images vectorielles</h2>

<p>
    Une autre façon de représenter des images
    consiste à décrire les formes géométriques
    qui composent l'image.
    On parle dans ce cas d'<i>images vectorielles</i>.
</p>

<p>
    Nous allons peu nous attarder sur les images vectorielles,
    mais le sujet est suffisamment important pour que nous
    en parlions au moins un petit peu !
</p>

<p>
    À la différence des images matricielles,
    le contenu d'une image vectorielle n'est pas
    décrit par une matrice de pixels, mais par
    un ensemble de formes géométriques.
</p>

<p>
    Un des principaux avantages des images vectorielles
    est qu'elles sont redimensionnables
    sans perte de qualité.
    En effet, les formes géométriques
    qui composent l'image peuvent être
    mises à différentes échelles sans perdre
    de détails ou de précision, ce qui n'est pas le cas des images matricielles.
</p>

$tryout$
<p>
    Ci-dessous vous trouverez la même image représentée
    dans deux formats différents : un format matriciel
    et un format vectoriel.
    Utilisez la barre de zoom pour voir ce qui se passe
    lorsque vous zoomez sur l'image en version vectorielle
    et comparez avec ce qui se passe lorsque vous zoomez
    sur l'image en version matricielle.
</p>

<style>

.image-container {
    position: relative;
    padding-bottom: 20px;
    display: flex;
    flex-direction: column;
    width: 100%;
    overflow: hidden;
}

.image-zoomable {
    overflow: scroll;
    overscroll-behavior-x: none;
    width: fit-content;
    max-width: 100%;
    height: 260px;
    margin: auto;
    flex: 1 1 auto;
}

.image-zoomable svg, .image-zoomable img {
    transform-origin: 0 0;
    image-rendering: pixelated;
    user-select: none;
    cursor: grab;
    margin: auto;

}

.image-controls {
    flex: 0 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 1em;
    flex-direction: row;
    gap: 1em;
}

.image-controls label {
    flex-grow: 0;
}

.image-controls input {
    flex-grow: 1;
}

.image-wrapper {
    width: 250px;
    height: 250px;
}
</style>

<div class="cols-2">
    <div class="image-container">
        <div class="image-zoomable">
            <div class="image-wrapper">
                <svg width="250" height="250">
                    <defs>
                        <linearGradient spreadMethod="pad" y2="0" x2="0" y1="0.68439" x1="0.41797" id="svg_3">
                            <stop offset="0" stop-opacity="0.99609" stop-color="#e81212"/>
                            <stop offset="1" stop-opacity="0.99609" stop-color="#ff7f00"/>
                        </linearGradient>
                        <linearGradient spreadMethod="pad" y2="0" x2="0" y1="0.68439" x1="0.41797" id="svg_4">
                            <stop offset="0" stop-opacity="0.99219" stop-color="#0e822f"/>
                            <stop offset="1" stop-opacity="0.99219" stop-color="#40c456"/>
                        </linearGradient>
                        <linearGradient y2="0" x2="1" y1="0" x1="0" id="svg_11">
                            <stop offset="0" stop-opacity="0.99609" stop-color="#f2cc0e"/>
                            <stop offset="1" stop-opacity="0.99609" stop-color="#d1c11b"/>
                        </linearGradient>
                    </defs>
                    <g>
                        <polygon transform="rotate(-8.43362 117.507 88.5455)" id="svg_20" points="45,72 100,72 118,20 135,72 190,72 145,105 162,158 118,125 73,158 90,105 45,72" stroke-width="2" stroke="#8c7c04" fill="url(#svg_11)"/>
                        <ellipse stroke-width="2" stroke="#7f0000" ry="42.5" rx="43" id="svg_1" cy="146.49865" cx="141.50149" fill="url(#svg_3)"/>
                        <polygon transform="rotate(15.4538 138 106.499)" stroke-width="2" stroke="#054927" id="svg_5" points="137,81 125,123 136,132 151,115 137,81" opacity="1" fill="url(#svg_4)"/>
                        <path stroke="#492605" id="svg_6" d="m128.76698,133.33239l-18.76685,-34.36765c-2.33333,-4.39706 11.4233,-6.63235 11.4233,-6.63235c10.5,37.16667 8.1595,30.14706 8.1595,29.54412c3.5,9.60294 16.319,-9.64706 -0.81595,11.45588z" opacity="1" stroke-width="2" fill="#7f3f00"/>
                        <text transform="rotate(-17.6739 157.385 198.004)" font-weight="normal" xml:space="preserve" text-anchor="start" font-family="'Helvetica'" font-size="24" id="svg_21" y="206.50364" x="72.00257" stroke-width="0" stroke="#8c7c04" fill="#000000">sur les pommes</text>
                        <text transform="rotate(-17.8376 55.502 201.837)" xml:space="preserve" text-anchor="start" font-family="'Helvetica'" font-size="36" id="svg_26" y="214.58887" x="9.99581" stroke="#f72e2e" fill="#e80000">-20%</text>
                    </g>
                </svg>
            </div>
        </div>
        <div class="image-controls">
            <input type="range" min="1" max="20" step="0.5" value="1" class="zoom-range" id="zoom-range-1" />
            <label for="zoom-range-1">100%</label>
        </div>
    </div>
    <div class="image-container">
        <div class="image-zoomable">
            <div class="image-wrapper">
                <img src="/docs/png/pommes.png" draggable="false" />
            </div>
        </div>
        <div class="image-controls">
            <input type="range" min="1" max="20" step="0.5" value="1" class="zoom-range" id="zoom-range-2" />
            <label for="zoom-range-2">100%</label>
        </div>
    </div>
</div>

<script type="text/javascript">
(function() {
    const containers = document.querySelectorAll('.image-container');
    const zoomables = [];
    const images = [];
    const wrappers = [];
    const ranges = [];
    const labels = [];
    for (let container of containers) {
        const zoomable = container.querySelector('.image-zoomable');
        zoomables.push(zoomable);
        const image = zoomable.querySelector('svg, img');
        images.push(image);
        const wrapper = zoomable.querySelector('.image-wrapper');
        wrappers.push(wrapper);
        const startWidth = 250;
        const startHeight = 250;

        const controls = container.querySelector('.image-controls');
        const range = controls.querySelector('.zoom-range');
        ranges.push(range);
        const label = controls.querySelector('label');
        labels.push(label);
        let zoom = 1;
        range.addEventListener('input', function() {
            const value = range.value;

            const scrollLeft = zoomable.scrollLeft;
            const scrollTop = zoomable.scrollTop;

            let focusLeft = scrollLeft + zoomable.clientWidth / 2;
            let focusTop = scrollTop + zoomable.clientHeight / 2;

            console.log(focusLeft, focusTop);

            for (i of images) {
                i.style.transform = `scale($${value})`;
            }
            for (w of wrappers) {
                w.style.width = `$${startWidth * value}px`;
                w.style.height = `$${startHeight * value}px`;
            }
            for (l of labels) {
                l.textContent = `$${value * 100}%`;
            }
            for (r of ranges) {
                r.value = value;
            }

            focusLeft *= value / zoom;
            focusTop *= value / zoom;

            for (z of zoomables) {
                z.scrollLeft = focusLeft - z.clientWidth / 2;
                z.scrollTop = focusTop - z.clientHeight / 2;
            }

            zoom = value;
        });

        // Moving around with the mouse
        let mouseDown = false;
        let lastX = 0;
        let lastY = 0;

        zoomable.addEventListener("scroll", function(event) {
            console.log('scroll', event);
            if (mouseDown) {
                event.preventDefault();
            }
            else {
                const scrollLeft = zoomable.scrollLeft;
                const scrollTop = zoomable.scrollTop;
                for (z of zoomables) {
                    z.scrollLeft = scrollLeft;
                    z.scrollTop = scrollTop;
                }
            }
        }, false);

        zoomable.addEventListener('mousedown', function(event) {
            mouseDown = true;
            lastX = event.clientX;
            lastY = event.clientY;
            document.body.classList.add('grabbing');
        });

        document.addEventListener('mouseup', function(event) {
            mouseDown = false;
            document.body.classList.remove('grabbing');
        });

        document.addEventListener('mousemove', function(event) {
            if (document.hasFocus() && mouseDown) {
                const deltaX = event.clientX - lastX;
                const deltaY = event.clientY - lastY;
                for (z of zoomables) {
                    z.scrollLeft -= deltaX;
                    z.scrollTop -= deltaY;
                }
                lastX = event.clientX;
                lastY = event.clientY;
            }
        });

        // Ungrab when the document loses focus
        document.addEventListener('blur', function(event) {
            mouseDown = false;
            document.body.classList.remove('grabbing');
        });
    }
})();
</script>
$endtryout$

$remark$
<p>
    Il n'est pas rare dans des séries télévisées ou des films
    de voir des policiers zoomer sur une image
    pour y révéler des détails cachés, comme dans l'extrait
    suivant du film <i>Blade Runner</i>, un film de science-fiction de 1982 :
</p>

<iframe class="video" src="https://www.youtube.com/embed/qHepKd38pr0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>    

<p>
    Dans l'extrait, on voit le personnage de Rick Deckard, joué par Harrison Ford,
    zoomer sur une image pour y découvrir un détail caché qui lui permet de résoudre
    une enquête.
    Des techniques similaires sont aussi utilisées dans des séries
    qui se veulent réalistes, comme par exemple dans la série <i>Les Experts</i> :
</p>

<iframe class="video" src="https://www.youtube.com/embed/I_8ZH1Ggjk0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>
    Le genre de zoom que l'on voit dans ces extraits est complètement fantaisiste.
    En effet, les images capturées par les appareils photos ou les dispositifs de surveillance
    ont une définition fixe, et il donc est impossible d'y révéler
    des détails qui n'y sont pas.
</p>

<p>
    Ce genre de scènes a d'ailleurs inspiré de nombreuses parodies,
    comme celle-ci :
</p>

<iframe class="video" src="https://www.youtube.com/embed/JMIHNiR3CP8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

$endremark$

<h3>Applicabilité des images vectorielles</h3>

<p>
    Comme nous l'avons vu, les images vectorielles
    sont très facilement redimensionnables
    sans perte de qualité.
    Nous pourrions donc être tentés de n'utiliser
    que des images vectorielles.
    Cependant, certaines images se prêtent mal
    à une représentation vectorielle.
    Aussi, les dispositifs de capture d'images
    produisent généralement des images matricielles.
</p>

<p>
    Par exemple, il est difficile de représenter des
    photographies avec des images matricielles.
    En effet, il est très difficile de décomposer une photographie
    en formes géométriques simples sans
    retomber sur une description matricielle de l'image.
</p>

<p>
    En revanche, les images vectorielles sont très adaptées
    à la représentation de dessins, de schémas, de logos par exemple.
    En effet, ces images sont souvent descriptibles
    à l'aide de formes géométriques.
</p>

<p>
    Comme pour les images matricielles,
    il existe plusieurs formats de fichiers
    pour représenter des images vectorielles.
    Le format le plus connu est le format SVG,
    que nous allons brièvement aborder ici.
</p>

<h3>Le format SVG</h3>

<p>
    Le format SVG (<i lang="en">Scalable Vector Graphics</i>) est un format de fichier
    qui permet de représenter des images vectorielles.
    Il s'agit d'un format de fichier texte :
    le contenu du fichier est écrit en utilisant
    du texte.
    Ce texte est ensuite encodé selon un encodage de caractères
    tel que UTF-8 pour obtenir le contenu du fichier.
</p>

<p>
    Le contenu du fichier est décrit en utilisant
    des balises, comme en HTML (le langage utilisé pour décrire les pages web).
    Par exemple, voici un fichier SVG qui décrit un cercle rouge :
</p>

<div class="scroll-x">
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;svg width="300" height="300" xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;circle cx="150" cy="150" r="145" fill="red" /&gt;
&lt;/svg&gt;</pre>
</div>

<p>
    Et voici le résultat de ce fichier SVG :
</p>

<figure>
    <svg width="300" height="300" xmlns="http://www.w3.org/2000/svg" class="img-ex">
        <circle cx="150" cy="150" r="145" fill="red" />
    </svg>
    <figcaption>
        Un cercle rouge, représenté en SVG.
    </figcaption>
</figure>

<p>
    Il est possible d'ajouter des éléments
    additionnels, comme par exemple du texte :
</p>

<div class="scroll-x">
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;svg width="300" height="300" xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;circle cx="150" cy="150" r="145" fill="red" /&gt;
    &lt;text x="110" y="150" fill="yellow"&gt;Trop bien!&lt;/text&gt;
&lt;/svg&gt;</pre>
</div>

<figure>
    <svg width="300" height="300" xmlns="http://www.w3.org/2000/svg" class="img-ex">
        <circle cx="150" cy="150" r="145" fill="red" />
        <text x="110" y="150" fill="yellow">Trop bien!</text>
    </svg>
    <figcaption>
        Un cercle rouge et un texte, représentés en SVG.
    </figcaption>
</figure>

<h3>Logiciels de dessin vectoriel</h3>

<p>
    Bien qu'il soit techniquement possible de
    créer des images vectorielles en écrivant
    directement le code SVG,
    il est plus courant d'utiliser un ce qu'on
    appelle un logiciel de dessin vectoriel
    pour créer ou modifier des images vectorielles.
</p>

<p>
    Parmi les logiciels de dessin vectoriel les plus connus,
    on peut citer :
</p>

<ul>
    <li>
        <a href="https://inkscape.org/">Inkscape</a>,
        un logiciel libre et gratuit, disponible sur Windows, Mac et Linux.
    </li>
    <li>
        <a href="https://www.adobe.com/fr/products/illustrator.html">Adobe Illustrator</a>,
        un logiciel propriétaire, disponible sur Windows et Mac.
    </li>
</ul>

$selfcheck$
<p>
    Les images <select class="self-pick">
        <option data-correct>vectorielles</option>
        <option>matricielles</option>
    </select> peuvent être redimensionnées sans perte de qualité.
</p>
$endselfcheck$

$selfcheck$
<p>
    Un appareil photo numérique produit des images
    <select class="self-pick">
        <option>vectorielles</option>
        <option data-correct>matricielles</option>
    </select>.
    Les images produite par un tel appareil ont une définition
    <select class="self-pick">
        <option>infinie</option>
        <option data-correct>finie</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Les images matricielles sont plus adaptées que les images vectoriel à la représentation de
    <select class="self-pick">
        <option data-correct>photographies</option>
        <option>schéma</option>
        <option>logos</option>
    </select>.
</p>
$endselfcheck$

$selfcheck$
<p>
    Le format de fichier SVG est un format de fichier
    <select class="self-pick">
        <option>binaire</option>
        <option data-correct>textuel</option>
    </select>.
    Les éléments du fichier sont décrits à l'aide de
    <select class="self-pick">
        <option>jalons</option>
        <option data-correct>balises</option>
        <option>perches</option>
    </select>.
</p>

